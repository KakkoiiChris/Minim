package minim.parser

import minim.lexer.Lexer
import minim.lexer.Location
import minim.lexer.Token
import minim.lexer.Token.Type.*
import minim.parser.Expr.Binary.Operator.*
import minim.util.*

/**
 * The second stage of the interpreter; a recursive descent parser that parses a list of [statements][Stmt] from the given [tokens][Token].
 *
 * @param tokens the list of [tokens][Token] generated by the [Lexer]
 */
class Parser(private val lexer: Lexer) {
    private var token = lexer.next()

    /**
     * Parses a list of [statements][Stmt] until the [end-of-file][Token.Type.EndOfFile] [Token] is reached.
     *
     * @return a list of all [statements][Stmt] in the file
     */
    fun parse(): Stmts {
        val stmts = mutableListOf<Stmt>()

        while (!skip(EndOfFile)) {
            stmts.add(stmt())
        }

        return stmts
    }

    /**
     * Gets the current [Token] being parsed.
     *
     * @return the [Token] at index [pos]
     */
    private fun peek() =
        token

    /**
     * Increments the [pos] token pointer.
     */
    private fun step() {
        if (lexer.hasNext()) {
            token = lexer.next()
        }
    }

    /**
     * Gets whether any of the given [token types][types] match the current [token's][Token] type.
     *
     * @param types the [token types][Token.Type] to match
     *
     * @return `true` if any [type][Token.Type] matches, or `false` otherwise
     */
    private fun match(vararg types: Token.Type) =
        types.any { it == peek().type }

    /**
     * Gets whether the given [token type][type] matches the [current token's][peek] [type][Token.Type], and [advances][step] the parser if it does.
     *
     * @param type the [type][Token.Type] to match
     *
     * @return `true` if the [type] matches, or `false` otherwise
     */
    private fun skip(type: Token.Type) =
        if (peek().type == type) {
            step()
            true
        }
        else {
            false
        }

    /**
     * Tries to [skip] the given [type], and throws an [error][unexpectedTypeError] if it didn't match.
     *
     * @param type the [type][Token.Type] to match
     */
    private fun mustSkip(type: Token.Type) {
        if (!skip(type)) {
            unexpectedTypeError(peek().type, type, here())
        }
    }

    /**
     * Gets the [current token's][peek] [Location].
     *
     * @return the [location][Token.loc] of the [current token][peek]
     */
    private fun here() =
        peek().loc

    /**
     * Gets a single [statement][Stmt], and skips the [end-of-statement][Token.Type.Dot] token.
     *
     * @return one [Stmt]
     */
    private fun stmt(): Stmt {
        val stmt = when {
            match(Number)     -> numeric()

            match(Dollar)     -> text()

            match(Underscore) -> control()

            match(Backslash)  -> system()

            match(BigM)       -> memory()

            match(Dot)        -> Stmt.None(here())

            else              -> expression()
        }

        mustSkip(Dot)

        return stmt
    }

    /**
     * Tries to skip an [i][SmallI] or [f][SmallF] token, and gets a [Boolean] indicating 'int mode' for certain [statements][Stmt].
     *
     * @return `true` if an [i][SmallI] token is skipped, or `false` otherwise
     */
    private fun isIntMode() = when {
        skip(SmallI) -> true

        skip(SmallF) -> false

        else         -> false
    }

    /**
     * Gets a single numeric [statement][Stmt].
     *
     * @return one [Stmt]
     */
    private fun numeric(): Stmt {
        val loc = here()

        mustSkip(Number)

        return when {
            skip(LessSign)    -> Stmt.NumberOut(loc, isIntMode(), expr())

            skip(GreaterSign) -> Stmt.NumberIn(loc, isIntMode(), expr())

            else              -> invalidStatementHeaderError("#${peek().type}", loc)
        }
    }

    /**
     * Gets a single text [statement][Stmt].
     *
     * @return one [Stmt]
     */
    private fun text(): Stmt {
        val loc = here()

        mustSkip(Dollar)

        return when {
            skip(LessSign)    -> Stmt.TextOut(loc, expr())

            skip(GreaterSign) -> Stmt.TextIn(loc, isIntMode(), expr())

            skip(Exclamation) -> Stmt.TextFlush(loc)

            else              -> invalidStatementHeaderError("\$${peek().type}", loc)
        }
    }

    /**
     * Gets a single control [statement][Stmt].
     *
     * @return one [Stmt]
     */
    private fun control(): Stmt {
        val loc = here()

        mustSkip(Underscore)

        return when {
            skip(LessSign)    -> Stmt.Goto(loc, expr())

            skip(GreaterSign) -> Stmt.Label(loc, expr())

            skip(Caret)       -> Stmt.Jump(loc, expr())

            skip(Plus)        -> Stmt.Gosub(loc, expr())

            skip(Minus)       -> Stmt.Return(loc)

            else              -> invalidStatementHeaderError("_${peek().type}", loc)
        }
    }

    /**
     * Gets a single system [statement][Stmt].
     *
     * @return one [Stmt]
     */
    private fun system(): Stmt {
        val loc = here()

        mustSkip(Backslash)

        return when {
            skip(LessSign)    -> Stmt.SystemArg(loc, expr())

            skip(GreaterSign) -> Stmt.SystemYield(loc, isIntMode(), expr())

            skip(At)          -> Stmt.SystemCall(loc)

            skip(Exclamation) -> Stmt.SystemFlush(loc)

            else              -> invalidStatementHeaderError("\\${peek().type}", loc)
        }
    }

    /**
     * Gets a single memory [statement][Stmt].
     *
     * @return one [Stmt]
     */
    private fun memory(): Stmt {
        val loc = here()

        mustSkip(BigM)

        return when {
            skip(Plus)        -> Stmt.MemoryPush(loc)

            skip(Minus)       -> Stmt.MemoryPop(loc)

            skip(LessSign)    -> Stmt.MemoryOut(loc, expr())

            skip(GreaterSign) -> Stmt.MemoryIn(loc, expr())

            skip(Exclamation) -> Stmt.MemoryFlush(loc)

            else              -> invalidStatementHeaderError("M${peek().type}", loc)
        }
    }

    /**
     * Parses a single [expression][Expr], and either converts any top level assignments to their respective assignment statements, or gets an [expression statement][Stmt.Expression].
     *
     * @return one [single assignment][Stmt.SingleAssign],  [fixed range assignment][Stmt.SingleAssign], [relative range assignment][Stmt.SingleAssign], or [expression][Stmt.SingleAssign] statement
     */
    private fun expression(): Stmt {
        val loc = here()

        val expr = expr()

        if (expr is Expr.Binary && expr.operator == Assign) {
            return when (val left = expr.left) {
                is Expr.Single        -> Stmt.SingleAssign(expr.loc, left, expr.right)

                is Expr.FixedRange    -> Stmt.FixedRangeAssign(expr.loc, left, expr.right)

                is Expr.RelativeRange -> Stmt.RelativeRangeAssign(expr.loc, left, expr.right)

                else                  -> Stmt.Expression(loc, expr)
            }
        }

        return Stmt.Expression(loc, expr)
    }

    /**
     * Gets a single [expression][Expr].
     *
     * @return one [Expr]
     */
    private fun expr() = assign()

    /**
     * Gets a single [expression][Expr] with a possible assignment operator, and [desugars][compoundAssign] the compound assignment operators.
     *
     * @return one [Expr]
     */
    private fun assign(): Expr {
        val expr = conditional()

        return if (match(
                EqualSign,
                StarEqual,
                SlashEqual,
                PercentEqual,
                PlusEqual,
                MinusEqual,
                DoubleLessEqual,
                DoubleGreaterEqual,
                TripleGreaterEqual,
                AndEqual,
                CaretEqual,
                PipeEqual,
                DoubleAmpersandEqual,
                DoublePipeEqual
            )
        ) {
            val op = peek()

            mustSkip(op.type)

            when (op.type) {
                StarEqual            -> compoundAssign(op.loc, expr, Multiply)

                SlashEqual           -> compoundAssign(op.loc, expr, Divide)

                PercentEqual         -> compoundAssign(op.loc, expr, Modulus)

                PlusEqual            -> compoundAssign(op.loc, expr, Add)

                MinusEqual           -> compoundAssign(op.loc, expr, Subtract)

                DoubleLessEqual      -> compoundAssign(op.loc, expr, ShiftLeft)

                DoubleGreaterEqual   -> compoundAssign(op.loc, expr, ShiftRight)

                TripleGreaterEqual   -> compoundAssign(op.loc, expr, UnsignedShiftRight)

                AndEqual             -> compoundAssign(op.loc, expr, BitAnd)

                CaretEqual           -> compoundAssign(op.loc, expr, Xor)

                PipeEqual            -> compoundAssign(op.loc, expr, BitOr)

                DoubleAmpersandEqual -> compoundAssign(op.loc, expr, And)

                DoublePipeEqual      -> compoundAssign(op.loc, expr, Or)

                else                 -> Expr.Binary(op.loc, Assign, expr, assign())
            }
        }
        else {
            expr
        }
    }

    /**
     * Takes the location, left operand, and desugared operator, and gets the
     *
     * @return one desugared compound assignment operator
     */
    private fun compoundAssign(loc: Location, expr: Expr, operator: Expr.Binary.Operator) =
        Expr.Binary(loc, Assign, expr, Expr.Binary(loc, operator, expr, assign()))

    /**
     * Gets a single [expression][Expr] with a possible ternary operator.
     *
     * @return one [Expr]
     */
    private fun conditional(): Expr {
        var node = logicalOr()

        if (match(Question)) {
            val op = peek()

            mustSkip(op.type)

            val yes = conditional()

            mustSkip(Colon)

            val no = conditional()

            node = Expr.Ternary(op.loc, node, yes, no)
        }

        return node
    }

    /**
     * Gets a single [expression][Expr] with a possible logical or operator.
     *
     * @return one [Expr]
     */
    private fun logicalOr(): Expr {
        var node = logicalAnd()

        while (match(DoublePipe)) {
            val op = peek()

            mustSkip(op.type)

            node = Expr.Binary(op.loc, Expr.Binary.Operator[op.type], node, logicalAnd())
        }

        return node
    }

    /**
     * Gets a single [expression][Expr] with a possible logical and operator.
     *
     * @return one [Expr]
     */
    private fun logicalAnd(): Expr {
        var node = bitwiseOr()

        while (match(DoubleAmpersand)) {
            val op = peek()

            mustSkip(op.type)

            node = Expr.Binary(op.loc, Expr.Binary.Operator[op.type], node, bitwiseOr())
        }

        return node
    }

    /**
     * Gets a single [expression][Expr] with a possible bitwise or operator.
     *
     * @return one [Expr]
     */
    private fun bitwiseOr(): Expr {
        var node = bitwiseXor()

        while (match(Pipe)) {
            val op = peek()

            mustSkip(op.type)

            node = Expr.Binary(op.loc, Expr.Binary.Operator[op.type], node, bitwiseXor())
        }

        return node
    }

    /**
     * Gets a single [expression][Expr] with a possible bitwise exclusive or operator.
     *
     * @return one [Expr]
     */
    private fun bitwiseXor(): Expr {
        var node = bitwiseAnd()

        while (match(Caret)) {
            val op = peek()

            mustSkip(op.type)

            node = Expr.Binary(op.loc, Expr.Binary.Operator[op.type], node, bitwiseAnd())
        }

        return node
    }

    /**
     * Gets a single [expression][Expr] with a possible bitwise and operator.
     *
     * @return one [Expr]
     */
    private fun bitwiseAnd(): Expr {
        var node = equality()

        while (match(Ampersand)) {
            val op = peek()

            mustSkip(op.type)

            node = Expr.Binary(op.loc, Expr.Binary.Operator[op.type], node, equality())
        }

        return node
    }

    /**
     * Gets a single [expression][Expr] with a possible equality operator.
     *
     * @return one [Expr]
     */
    private fun equality(): Expr {
        var node = relational()

        while (match(DoubleEqual, LessGreater)) {
            val op = peek()

            mustSkip(op.type)

            node = Expr.Binary(op.loc, Expr.Binary.Operator[op.type], node, relational())
        }

        return node
    }

    /**
     * Gets a single [expression][Expr] with a possible relational operator.
     *
     * @return one [Expr]
     */
    private fun relational(): Expr {
        var node = shift()

        while (match(LessSign, LessEqualSign, GreaterSign, GreaterEqualSign)) {
            val op = peek()

            mustSkip(op.type)

            node = Expr.Binary(op.loc, Expr.Binary.Operator[op.type], node, shift())
        }

        return node
    }

    /**
     * Gets a single [expression][Expr] with a possible bit shift operator.
     *
     * @return one [Expr]
     */
    private fun shift(): Expr {
        var node = additive()

        while (match(DoubleLess, DoubleGreater, TripleGreater)) {
            val op = peek()

            mustSkip(op.type)

            node = Expr.Binary(op.loc, Expr.Binary.Operator[op.type], node, additive())
        }

        return node
    }

    /**
     * Gets a single [expression][Expr] with a possible additive operator.
     *
     * @return one [Expr]
     */
    private fun additive(): Expr {
        var node = multiplicative()

        while (match(Plus, Minus)) {
            val op = peek()

            mustSkip(op.type)

            node = Expr.Binary(op.loc, Expr.Binary.Operator[op.type], node, multiplicative())
        }

        return node
    }

    /**
     * Gets a single [expression][Expr] with a possible multiplicative operator.
     *
     * @return one [Expr]
     */
    private fun multiplicative(): Expr {
        var node = prefix()

        while (match(Star, Slash, Percent)) {
            val op = peek()

            mustSkip(op.type)

            node = Expr.Binary(op.loc, Expr.Binary.Operator[op.type], node, prefix())
        }

        return node
    }

    /**
     * Gets a single [expression][Expr] with a possible prefix operator.
     *
     * @return one [Expr]
     */
    private fun prefix(): Expr {
        return if (match(
                Minus,
                Exclamation,
                Question,
                Tilde,
                DoublePlus,
                DoubleMinus,
                DoubleQuestion,
                DoubleExclamation,
                DoubleTilde
            )
        ) {
            val op = peek()

            skip(op.type)

            Expr.Prefix(op.loc, Expr.Prefix.Operator[op.type], prefix())
        }
        else {
            postfix()
        }
    }

    /**
     * Gets a single [expression][Expr] with a possible postfix operator.
     *
     * @return one [Expr]
     */
    private fun postfix(): Expr {
        var expr = terminal()

        while (match(DoublePlus, DoubleMinus, DoubleQuestion, DoubleExclamation, DoubleTilde, SmallI, SmallF, SmallS)) {
            val op = peek()

            skip(op.type)

            expr = Expr.Postfix(op.loc, Expr.Postfix.Operator[op.type], expr)
        }

        return expr
    }

    /**
     * Gets a single terminal [expression][Expr], which is one of either a [value], a [nested expression][nested], a [memory accessor][access], an [array literal][array], or a [dynamic literal][dynamic].
     */
    private fun terminal(): Expr {
        return when {
            match(Value)      -> value()

            match(LeftParen)  -> nested()

            match(LeftSquare) -> access()

            match(LeftBrace)  -> array()

            match(Dynamic)    -> dynamic()

            else              -> invalidTerminalError(peek().type, here())
        }
    }

    /**
     * Gets a single [numberFormatError expression][Number] with the [value][Token.value] of the [current token][peek].
     *
     * @return one [number expression][Number]
     */
    private fun value(): Expr.Number {
        val token = peek()

        mustSkip(Value)

        return Expr.Number(token.loc, token.value)
    }

    /**
     * Gets a parenthesized [expression][expr], which wraps around back to the top of the precedence table.
     *
     * @return one [Expr]
     */
    private fun nested(): Expr {
        mustSkip(LeftParen)

        val expr = expr()

        mustSkip(RightParen)

        return expr
    }

    /**
     * Gets a memory accessor expression ([Single][Expr.Single], [Fixed Range][Expr.FixedRange], or [Relative Range][Expr.RelativeRange]).
     *
     * @return one [Expr]
     */
    private fun access(): Expr {
        val loc = here()

        mustSkip(LeftSquare)

        // []
        if (skip(RightSquare)) {
            return Expr.FixedRange(loc, Expr.None, Expr.None, Expr.None)
        }

        val a = if (match(Colon, At, RightSquare))
            Expr.None
        else
            expr()

        // [a]
        if (skip(RightSquare)) {
            return Expr.Single(loc, a)
        }

        val fixed = skip(Colon)

        if (!fixed) {
            mustSkip(At)
        }

        if (skip(RightSquare)) {
            return if (fixed) {
                // [a :]
                Expr.FixedRange(loc, a, Expr.None, Expr.None)
            }
            else {
                noRelativeRangeCountError(here())
            }
        }

        val b = if (match(Colon, RightSquare))
            Expr.None
        else
            expr()

        if (skip(RightSquare)) {
            return if (fixed) {
                // [a : b]
                Expr.FixedRange(loc, a, b, Expr.None)
            }
            else {
                // [a @ b]
                Expr.RelativeRange(loc, a, b, Expr.None)
            }
        }

        mustSkip(Colon)

        val c = if (match(RightSquare))
            Expr.None
        else
            expr()

        mustSkip(RightSquare)

        return if (fixed) {
            // [a : b : c]
            Expr.FixedRange(loc, a, b, c)
        }
        else {
            // [a @ b : c]
            Expr.RelativeRange(loc, a, b, c)
        }
    }

    /**
     * Gets a single [array literal][Expr.Array].
     *
     * @return one [Expr.Array]
     */
    private fun array(): Expr.Array {
        val token = peek()

        mustSkip(LeftBrace)

        val elements = mutableListOf<Expr>()

        do {
            val element = expr()

            if (element is Expr.Array) {
                invalidArrayElementError(element.loc)
            }

            elements += element
        }
        while (skip(Comma))

        mustSkip(RightBrace)

        return Expr.Array(token.loc, elements)
    }

    /**
     * Gets a single [dynamic literal][Expr.DynamicLiteral].
     *
     * @return one [Expr.DynamicLiteral]
     */
    private fun dynamic(): Expr.DynamicLiteral {
        val token = peek()

        mustSkip(Dynamic)

        val name = Expr.DynamicLiteral.Name[token.value.toInt().toChar()]!!

        return Expr.DynamicLiteral(token.loc, name)
    }
}