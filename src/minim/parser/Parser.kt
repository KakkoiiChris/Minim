package minim.parser

import minim.lexer.*
import minim.parser.Expr.Binary.Operator.*
import minim.util.*
import kotlin.reflect.KClass

/**
 * The second stage of the interpreter; a recursive descent parser that parses a list of [statements][Stmt] from the given [tokens][Token].
 *
 * @param tokens the list of [tokens][Token] generated by the [Lexer]
 */
class Parser(private val lexer: Lexer) {
    private var token = lexer.next()

    /**
     * Parses a list of [statements][Stmt] until the [end-of-file][Token.Type.EndOfFile] [Token] is reached.
     *
     * @return a list of all [statements][Stmt] in the file
     */
    fun parse(): Stmts {
        val stmts = mutableListOf<Stmt>()

        while (!skip(Symbol.END_OF_FILE)) {
            stmts.add(stmt())
        }

        return stmts
    }

    /**
     * Gets the current [Token] being parsed.
     *
     * @return the [Token] at index [pos]
     */
    private fun peek() =
        token

    /**
     * Increments the [pos] token pointer.
     */
    private fun step() {
        if (lexer.hasNext()) {
            token = lexer.next()
        }
    }

    /**
     * Gets whether any of the given [token types][types] match the current [token's][Token] type.
     *
     * @param types the [token types][Token.Type] to match
     *
     * @return `true` if any [type][Token.Type] matches, or `false` otherwise
     */
    private fun match(vararg types: Type) =
        types.any { it == peek().type }

    /**
     * Gets whether the given [token type][type] matches the [current token's][peek] [type][Token.Type], and [advances][step] the parser if it does.
     *
     * @param type the [type][Token.Type] to match
     *
     * @return `true` if the [type] matches, or `false` otherwise
     */
    private fun skip(type: Type) =
        if (peek().type == type) {
            step()
            true
        }
        else {
            false
        }

    /**
     * Tries to [skip] the given [type], and throws an [error][unexpectedTypeError] if it didn't match.
     *
     * @param type the [type][Token.Type] to match
     */
    private fun mustSkip(type: Type) {
        if (!skip(type)) {
            unexpectedTypeError(peek().type, type, here())
        }
    }

    private fun <T : Type> match(`class`: KClass<T>) =
        `class`.isInstance(peek().type)

    /**
     * Gets whether the given [token type][type] matches the [current token's][peek] [type][Token.Type], and [advances][step] the parser if it does.
     *
     * @param type the [type][Token.Type] to match
     *
     * @return `true` if the [type] matches, or `false` otherwise
     */
    private inline fun <reified T : Type> get(): T? {
        val type = peek().type

        return if (type is T) {
            step()
            type
        }
        else {
            null
        }
    }

    /**
     * Tries to [skip] the given [type], and throws an [error][unexpectedTypeError] if it didn't match.
     *
     * @param type the [type][Token.Type] to match
     */
    private inline fun <reified T : Type> mustGet(): T =
        get<T>() ?: TODO("CANNOT GET")//unexpectedTypeError(peek().type, type, here())

    /**
     * Gets the [current token's][peek] [Location].
     *
     * @return the [location][Token.loc] of the [current token][peek]
     */
    private fun here() =
        peek().loc

    /**
     * Gets a single [statement][Stmt], and skips the [end-of-statement][Token.Type.Dot] token.
     *
     * @return one [Stmt]
     */
    private fun stmt(): Stmt {
        val stmt = when {
            match(Symbol.POUND)      -> numeric()

            match(Symbol.DOLLAR)     -> text()

            match(Symbol.UNDERSCORE) -> control()

            match(Symbol.BACKSLASH)  -> system()

            match(Symbol.BIG_M)      -> memory()

            match(Symbol.DOT)        -> Stmt.None(here())

            else                     -> expression()
        }

        mustSkip(Symbol.DOT)

        return stmt
    }

    /**
     * Tries to skip an [i][Symbol.SMALL_I] or [f][Symbol.SMALL_F] token, and gets a [Boolean] indicating 'int mode' for certain [statements][Stmt].
     *
     * @return `true` if an [i][Symbol.SMALL_I] token is skipped, or `false` otherwise
     */
    private fun isIntMode() = when {
        skip(Symbol.SMALL_I) -> true

        skip(Symbol.SMALL_F) -> false

        else                 -> false
    }

    /**
     * Gets a single numeric [statement][Stmt].
     *
     * @return one [Stmt]
     */
    private fun numeric(): Stmt {
        val loc = here()

        mustSkip(Symbol.POUND)

        return when {
            skip(Symbol.LESS)    -> Stmt.NumberOut(loc, isIntMode(), expr())

            skip(Symbol.GREATER) -> Stmt.NumberIn(loc, isIntMode(), expr())

            else                 -> invalidStatementHeaderError("#${peek().type}", loc)
        }
    }

    /**
     * Gets a single text [statement][Stmt].
     *
     * @return one [Stmt]
     */
    private fun text(): Stmt {
        val loc = here()

        mustSkip(Symbol.DOLLAR)

        return when {
            skip(Symbol.LESS)    -> Stmt.TextOut(loc, expr())

            skip(Symbol.GREATER) -> Stmt.TextIn(loc, isIntMode(), expr())

            skip(Symbol.BANG)    -> Stmt.TextFlush(loc)

            else                 -> invalidStatementHeaderError("\$${peek().type}", loc)
        }
    }

    /**
     * Gets a single control [statement][Stmt].
     *
     * @return one [Stmt]
     */
    private fun control(): Stmt {
        val loc = here()

        mustSkip(Symbol.UNDERSCORE)

        return when {
            skip(Symbol.LESS)    -> Stmt.Goto(loc, expr())

            skip(Symbol.GREATER) -> Stmt.Label(loc, expr())

            skip(Symbol.CARET)   -> Stmt.Jump(loc, expr())

            skip(Symbol.PLUS)    -> Stmt.Gosub(loc, expr())

            skip(Symbol.DASH)    -> Stmt.Return(loc)

            else                 -> invalidStatementHeaderError("_${peek().type}", loc)
        }
    }

    /**
     * Gets a single system [statement][Stmt].
     *
     * @return one [Stmt]
     */
    private fun system(): Stmt {
        val loc = here()

        mustSkip(Symbol.BACKSLASH)

        return when {
            skip(Symbol.LESS)    -> Stmt.SystemArg(loc, expr())

            skip(Symbol.GREATER) -> Stmt.SystemYield(loc, isIntMode(), expr())

            skip(Symbol.AT)      -> Stmt.SystemCall(loc)

            skip(Symbol.BANG)    -> Stmt.SystemFlush(loc)

            else                 -> invalidStatementHeaderError("\\${peek().type}", loc)
        }
    }

    /**
     * Gets a single memory [statement][Stmt].
     *
     * @return one [Stmt]
     */
    private fun memory(): Stmt {
        val loc = here()

        mustSkip(Symbol.BIG_M)

        return when {
            skip(Symbol.PLUS)    -> Stmt.MemoryPush(loc)

            skip(Symbol.DASH)    -> Stmt.MemoryPop(loc)

            skip(Symbol.LESS)    -> Stmt.MemoryOut(loc, expr())

            skip(Symbol.GREATER) -> Stmt.MemoryIn(loc, expr())

            skip(Symbol.BANG)    -> Stmt.MemoryFlush(loc)

            else                 -> invalidStatementHeaderError("M${peek().type}", loc)
        }
    }

    /**
     * Parses a single [expression][Expr], and either converts any top level assignments to their respective assignment statements, or gets an [expression statement][Stmt.Expression].
     *
     * @return one [single assignment][Stmt.SingleAssign],  [fixed range assignment][Stmt.SingleAssign], [relative range assignment][Stmt.SingleAssign], or [expression][Stmt.SingleAssign] statement
     */
    private fun expression(): Stmt {
        val loc = here()

        val expr = expr()

        if (expr is Expr.Binary && expr.operator == ASSIGN) {
            return when (val left = expr.left) {
                is Expr.Single        -> Stmt.SingleAssign(expr.loc, left, expr.right)

                is Expr.FixedRange    -> Stmt.FixedRangeAssign(expr.loc, left, expr.right)

                is Expr.RelativeRange -> Stmt.RelativeRangeAssign(expr.loc, left, expr.right)

                else                  -> Stmt.Expression(loc, expr)
            }
        }

        return Stmt.Expression(loc, expr)
    }

    /**
     * Gets a single [expression][Expr].
     *
     * @return one [Expr]
     */
    private fun expr() = assign()

    /**
     * Gets a single [expression][Expr] with a possible assignment operator, and [desugars][compoundAssign] the compound assignment operators.
     *
     * @return one [Expr]
     */
    private fun assign(): Expr {
        val expr = conditional()

        return if (match(
                Symbol.EQUAL,
                Symbol.STAR_EQUAL,
                Symbol.SLASH_EQUAL,
                Symbol.PERCENT_EQUAL,
                Symbol.PLUS_EQUAL,
                Symbol.DASH_EQUAL,
                Symbol.DOUBLE_LESS_EQUAL,
                Symbol.DOUBLE_GREATER_EQUAL,
                Symbol.TRIPLE_GREATER_EQUAL,
                Symbol.AMPERSAND_EQUAL,
                Symbol.CARET_EQUAL,
                Symbol.PIPE_EQUAL,
                Symbol.DOUBLE_AMPERSAND_EQUAL,
                Symbol.DOUBLE_PIPE_EQUAL
            )
        ) {
            val op = peek()

            mustSkip(op.type)

            when (op.type) {
                Symbol.STAR_EQUAL             -> compoundAssign(op.loc, expr, MULTIPLY)

                Symbol.SLASH_EQUAL            -> compoundAssign(op.loc, expr, DIVIDE)

                Symbol.PERCENT_EQUAL          -> compoundAssign(op.loc, expr, MODULUS)

                Symbol.PLUS_EQUAL             -> compoundAssign(op.loc, expr, ADD)

                Symbol.DASH_EQUAL             -> compoundAssign(op.loc, expr, SUBTRACT)

                Symbol.DOUBLE_LESS_EQUAL      -> compoundAssign(op.loc, expr, SHIFT_LEFT)

                Symbol.DOUBLE_GREATER_EQUAL   -> compoundAssign(op.loc, expr, SHIFT_RIGHT)

                Symbol.TRIPLE_GREATER_EQUAL   -> compoundAssign(op.loc, expr, UNSIGNED_SHIFT_RIGHT)

                Symbol.AMPERSAND_EQUAL        -> compoundAssign(op.loc, expr, BIT_AND)

                Symbol.CARET_EQUAL            -> compoundAssign(op.loc, expr, BIT_XOR)

                Symbol.PIPE_EQUAL             -> compoundAssign(op.loc, expr, BIT_OR)

                Symbol.DOUBLE_AMPERSAND_EQUAL -> compoundAssign(op.loc, expr, AND)

                Symbol.DOUBLE_PIPE_EQUAL      -> compoundAssign(op.loc, expr, OR)

                else                          -> Expr.Binary(op.loc, ASSIGN, expr, assign())
            }
        }
        else {
            expr
        }
    }

    /**
     * Takes the location, left operand, and desugared operator, and gets the
     *
     * @return one desugared compound assignment operator
     */
    private fun compoundAssign(loc: Location, expr: Expr, operator: Expr.Binary.Operator) =
        Expr.Binary(loc, ASSIGN, expr, Expr.Binary(loc, operator, expr, assign()))

    /**
     * Gets a single [expression][Expr] with a possible ternary operator.
     *
     * @return one [Expr]
     */
    private fun conditional(): Expr {
        var node = logicalOr()

        if (match(Symbol.QUESTION)) {
            val op = peek()

            mustSkip(op.type)

            val yes = conditional()

            mustSkip(Symbol.COLON)

            val no = conditional()

            node = Expr.Ternary(op.loc, node, yes, no)
        }

        return node
    }

    /**
     * Gets a single [expression][Expr] with a possible logical or operator.
     *
     * @return one [Expr]
     */
    private fun logicalOr(): Expr {
        var node = logicalAnd()

        while (match(Symbol.DOUBLE_PIPE)) {
            val op = peek()

            val symbol = mustGet<Symbol>()

            node = Expr.Binary(op.loc, Expr.Binary.Operator[symbol], node, logicalAnd())
        }

        return node
    }

    /**
     * Gets a single [expression][Expr] with a possible logical and operator.
     *
     * @return one [Expr]
     */
    private fun logicalAnd(): Expr {
        var node = bitwiseOr()

        while (match(Symbol.DOUBLE_AMPERSAND)) {
            val op = peek()

            val symbol = mustGet<Symbol>()

            node = Expr.Binary(op.loc, Expr.Binary.Operator[symbol], node, bitwiseOr())
        }

        return node
    }

    /**
     * Gets a single [expression][Expr] with a possible bitwise or operator.
     *
     * @return one [Expr]
     */
    private fun bitwiseOr(): Expr {
        var node = bitwiseXor()

        while (match(Symbol.PIPE)) {
            val op = peek()

            val symbol = mustGet<Symbol>()

            node = Expr.Binary(op.loc, Expr.Binary.Operator[symbol], node, bitwiseXor())
        }

        return node
    }

    /**
     * Gets a single [expression][Expr] with a possible bitwise exclusive or operator.
     *
     * @return one [Expr]
     */
    private fun bitwiseXor(): Expr {
        var node = bitwiseAnd()

        while (match(Symbol.CARET)) {
            val op = peek()

            val symbol = mustGet<Symbol>()

            node = Expr.Binary(op.loc, Expr.Binary.Operator[symbol], node, bitwiseAnd())
        }

        return node
    }

    /**
     * Gets a single [expression][Expr] with a possible bitwise and operator.
     *
     * @return one [Expr]
     */
    private fun bitwiseAnd(): Expr {
        var node = equality()

        while (match(Symbol.AMPERSAND)) {
            val op = peek()

            val symbol = mustGet<Symbol>()

            node = Expr.Binary(op.loc, Expr.Binary.Operator[symbol], node, equality())
        }

        return node
    }

    /**
     * Gets a single [expression][Expr] with a possible equality operator.
     *
     * @return one [Expr]
     */
    private fun equality(): Expr {
        var node = relational()

        while (match(Symbol.DOUBLE_EQUAL, Symbol.LESS_GREATER)) {
            val op = peek()

            val symbol = mustGet<Symbol>()

            node = Expr.Binary(op.loc, Expr.Binary.Operator[symbol], node, relational())
        }

        return node
    }

    /**
     * Gets a single [expression][Expr] with a possible relational operator.
     *
     * @return one [Expr]
     */
    private fun relational(): Expr {
        var node = shift()

        while (match(Symbol.LESS, Symbol.LESS_EQUAL, Symbol.GREATER, Symbol.GREATER_EQUAL)) {
            val op = peek()

            val symbol = mustGet<Symbol>()

            node = Expr.Binary(op.loc, Expr.Binary.Operator[symbol], node, shift())
        }

        return node
    }

    /**
     * Gets a single [expression][Expr] with a possible bit shift operator.
     *
     * @return one [Expr]
     */
    private fun shift(): Expr {
        var node = additive()

        while (match(Symbol.DOUBLE_LESS, Symbol.DOUBLE_GREATER, Symbol.TRIPLE_GREATER)) {
            val op = peek()

            val symbol = mustGet<Symbol>()

            node = Expr.Binary(op.loc, Expr.Binary.Operator[symbol], node, additive())
        }

        return node
    }

    /**
     * Gets a single [expression][Expr] with a possible additive operator.
     *
     * @return one [Expr]
     */
    private fun additive(): Expr {
        var node = multiplicative()

        while (match(Symbol.PLUS, Symbol.DASH)) {
            val op = peek()

            val symbol = mustGet<Symbol>()

            node = Expr.Binary(op.loc, Expr.Binary.Operator[symbol], node, multiplicative())
        }

        return node
    }

    /**
     * Gets a single [expression][Expr] with a possible multiplicative operator.
     *
     * @return one [Expr]
     */
    private fun multiplicative(): Expr {
        var node = prefix()

        while (match(Symbol.STAR, Symbol.SLASH, Symbol.PERCENT)) {
            val op = peek()

            val symbol = mustGet<Symbol>()

            node = Expr.Binary(op.loc, Expr.Binary.Operator[symbol], node, prefix())
        }

        return node
    }

    /**
     * Gets a single [expression][Expr] with a possible prefix operator.
     *
     * @return one [Expr]
     */
    private fun prefix(): Expr {
        return if (match(
                Symbol.DASH,
                Symbol.BANG,
                Symbol.QUESTION,
                Symbol.TILDE,
                Symbol.DOUBLE_PLUS,
                Symbol.DOUBLE_DASH,
                Symbol.DOUBLE_QUESTION,
                Symbol.DOUBLE_BANG,
                Symbol.DOUBLE_TILDE
            )
        ) {
            val op = peek()

            val symbol = mustGet<Symbol>()

            Expr.Prefix(op.loc, Expr.Prefix.Operator[symbol], prefix())
        }
        else {
            postfix()
        }
    }

    /**
     * Gets a single [expression][Expr] with a possible postfix operator.
     *
     * @return one [Expr]
     */
    private fun postfix(): Expr {
        var expr = terminal()

        while (match(
                Symbol.DOUBLE_PLUS,
                Symbol.DOUBLE_DASH,
                Symbol.DOUBLE_QUESTION,
                Symbol.DOUBLE_BANG,
                Symbol.DOUBLE_TILDE,
                Symbol.SMALL_I,
                Symbol.SMALL_F,
                Symbol.SMALL_S
            )
        ) {
            val op = peek()

            val symbol = mustGet<Symbol>()

            expr = Expr.Postfix(op.loc, Expr.Postfix.Operator[symbol], expr)
        }

        return expr
    }

    /**
     * Gets a single terminal [expression][Expr], which is one of either a [value], a [nested expression][nested], a [memory accessor][access], an [array literal][array], or a [dynamic literal][dynamic].
     */
    private fun terminal(): Expr {
        return when {
            match(Symbol.LEFT_PAREN)  -> nested()

            match(Symbol.LEFT_SQUARE) -> access()

            match(Symbol.LEFT_BRACE)  -> array()

            match(Value::class)       -> value()

            match(Dynamic::class)     -> dynamic()

            else                      -> invalidTerminalError(peek().type, here())
        }
    }

    /**
     * Gets a single [numberFormatError expression][Number] with the [value][Value.value] of the [current token][peek].
     *
     * @return one [number expression][Number]
     */
    private fun value(): Expr.Number {
        val token = peek()

        val value = mustGet<Value>().value

        return Expr.Number(token.loc, value)
    }

    /**
     * Gets a parenthesized [expression][expr], which wraps around back to the top of the precedence table.
     *
     * @return one [Expr]
     */
    private fun nested(): Expr {
        mustSkip(Symbol.LEFT_PAREN)

        val expr = expr()

        mustSkip(Symbol.RIGHT_PAREN)

        return expr
    }

    /**
     * Gets a memory accessor expression ([Single][Expr.Single], [Fixed Range][Expr.FixedRange], or [Relative Range][Expr.RelativeRange]).
     *
     * @return one [Expr]
     */
    private fun access(): Expr {
        val loc = here()

        mustSkip(Symbol.LEFT_SQUARE)

        // []
        if (skip(Symbol.RIGHT_SQUARE)) {
            return Expr.FixedRange(loc, Expr.None, Expr.None, Expr.None)
        }

        val a = if (match(Symbol.COLON, Symbol.AT, Symbol.RIGHT_SQUARE))
            Expr.None
        else
            expr()

        // [a]
        if (skip(Symbol.RIGHT_SQUARE)) {
            return Expr.Single(loc, a)
        }

        val fixed = skip(Symbol.COLON)

        if (!fixed) {
            mustSkip(Symbol.AT)
        }

        if (skip(Symbol.RIGHT_SQUARE)) {
            return if (fixed) {
                // [a :]
                Expr.FixedRange(loc, a, Expr.None, Expr.None)
            }
            else {
                noRelativeRangeCountError(here())
            }
        }

        val b = if (match(Symbol.COLON, Symbol.RIGHT_SQUARE))
            Expr.None
        else
            expr()

        if (skip(Symbol.RIGHT_SQUARE)) {
            return if (fixed) {
                // [a : b]
                Expr.FixedRange(loc, a, b, Expr.None)
            }
            else {
                // [a @ b]
                Expr.RelativeRange(loc, a, b, Expr.None)
            }
        }

        mustSkip(Symbol.COLON)

        val c = if (match(Symbol.RIGHT_SQUARE))
            Expr.None
        else
            expr()

        mustSkip(Symbol.RIGHT_SQUARE)

        return if (fixed) {
            // [a : b : c]
            Expr.FixedRange(loc, a, b, c)
        }
        else {
            // [a @ b : c]
            Expr.RelativeRange(loc, a, b, c)
        }
    }

    /**
     * Gets a single [array literal][Expr.Array].
     *
     * @return one [Expr.Array]
     */
    private fun array(): Expr.Array {
        val token = peek()

        mustSkip(Symbol.LEFT_BRACE)

        val elements = mutableListOf<Expr>()

        do {
            val element = expr()

            if (element is Expr.Array) {
                invalidArrayElementError(element.loc)
            }

            elements += element
        }
        while (skip(Symbol.COMMA))

        mustSkip(Symbol.RIGHT_BRACE)

        return Expr.Array(token.loc, elements)
    }

    /**
     * Gets a single [dynamic literal][Expr.DynamicLiteral].
     *
     * @return one [Expr.DynamicLiteral]
     */
    private fun dynamic(): Expr.DynamicLiteral {
        val token = peek()

        val char = mustGet<Dynamic>().char

        val name = Expr.DynamicLiteral.Name[char]!!

        return Expr.DynamicLiteral(token.loc, name)
    }
}